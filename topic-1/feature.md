# 1.1 特征

我并不想，你似乎也没资格为 Go 增添什么新的荣誉。在此仅从这几年的使用经验说说个人看法，一如书名《学习笔记》那样。

## 语法简单

抛开语法样式不谈，单就类型和规则而言，Go 与 C99、C11 相似之处颇多，这也是我能接受它被冠以 "NextC" 名号的重要原因。

即使我是个坚定的 C 拥趸，也不得不承认，它处于简单和复杂的两极。C 简单到你每写下一行代码，都能以脑中想象出编译后的模板，指令如何执行，内存如何分配，等待。而 C 的复杂在于，它有太多隐晦而不着边际的规则，着实让人头疼。相比较而言，Go 从零开始，没有历史包袱，在汲取众多经验教训后，可从头规划一个规则严谨、条理简单的世界。

人们习惯拿关键字和控制语句的数量来作为 Go 简单的特征，我倒觉得这并不合适。诚然，更少的语言规则有助于人们学习，这无可厚非。但更重要的在于，语言规则严谨，没有卢歧义，更没什么黑魔法变异用法。任何人写出的代码都基本一致，这才是简单的本质。放弃部分 “灵活” 和 “自由”，换来更好的维护性，我觉得是值得的。

将 `++`、 `--` 从运算符降级为语句，保留指针，但默认阻止指针运营。初时的不习惯，并不能掩盖它带来的长期的好处。还有，将切片和字典作为内置类型，从运行时的层面进行优化，这也算是一种 “简单”。

## 并发模型

时至今日，并发编程已成为程序员的基本技能，在各个技术社区都能看到诸多与之相关的讨论主题。究竟哪种方式是最佳并发编程体验，或许会一直争论下去。但 Go 却一反常态做了件极大胆的事，从根子上将一切都并发化，运行是用 Goroutine 运行所有的一切，包括 `main.main` 入口陈函数。

可以说，Goroutine 是 Go 最显著的特征。它用类协程的方式来处理并发单元，却又在运行时层面做了更深度的优化处理。这使得语法上的并发编程变得极为容易，无须处理回调，无须关注执行绪切换，仅一个关键字，简单而自然。

搭配 channel，实现 CSP 模型。将并发单元间的数据耦合拆解开来，各司其职，这对所有纠结于内存共享，锁粒度的开发人员都是一个可期盼的解脱。若说有所有不足，那就是应该有个更大的计划，将通信从进程内拓展到进程外，实现真正意义上的分布式。

